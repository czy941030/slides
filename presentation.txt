在海量数据中查询有时间范围限制的最频繁路径

frame 1
研究价值：
GPS数据的使得收集海量轨迹数据成为可能
在出行规划
优化城市交通

frame 3
问题定义的描述
海量数据的假设：
11,000,000条轨迹
假设所有数据不能全部放在内存中，缓存需要放在交换页面文件中

frame 4
之前的工作大多没有满足三个性质
后缀最优
长度无关
无瓶颈
过去工作不合理的主要原因是只使用了一个值来描述一条路径
这篇文章用一个序列来描述一条路径的频繁度
整篇论文的工作主要有以下几个部分：
首先明确了需要满足的三个性质
通过一些定义提出了整个问题的描述
设计了两种心新颖的索引来加速缓存，减少硬盘读写
提出了一种基于动态规划的类似Bellman－Ford的算法
进行了比较详细的实验

frame 6
后缀最优
一条路径是MFP，则它的所有后缀都是MFP
长度无关
长度不能是度量一条路径是不是MFP的一个因子
例如MPR算法趋向于选中间点尽可能少的
无瓶颈性
不应当包含不常用的边

frame 7
不满足后缀最优的例子：G1
不满足长度无关的例子：G4
不满足无瓶颈性的例子：G5

frame 9
定义

frame 10
Footmark
在图G上，在轨迹集合内，定义了起终点，和时间范围
在时间范围内，到达终点的所有子轨迹，即 Footmark

frame 12
Footmark Graph
边权：经过这条边的Footmark的条数
Gf是G的子图，包含所有边权非0的边

frame 13
Path Frequency
路径上所有边权的升序排列

frame 14
更频繁关系
P比P‘更频繁，当
P是P’的前缀
或者催在某个i使得F[P,i]>F[P',i]
当不等时，称严格更频繁
(10,10,10) ≽ (1,100), 
(1,2) ≽ (1,2,3),
(5,6,9) ≽ (5,6,7,12),

frame 15
这是一个全序关系
MFP：给定Gf和起终点的情况下所有路径中最频繁的一条路径
问题描述：给定图，轨迹集合，起终点，时间限制，求MFP

frame 17
算法分两步，
第一步求出Gf
第二部在Gf中找出MFP
根据问题的定义，可知其满足后缀最优定理

frame 18
FMI
对于到达每个点的所有子轨迹
把它们按照到达时间的顺序用B＋树维护起来
B＋树的每个叶子节点存着轨迹的id和到达时间
FMI－search用来找出满足终点时间满足T限制的所有子轨迹

frame 20
首先通过FMI求出所有相关的字轨迹
对于每条轨迹，排除之前几个不在时间范围内的点
然后把剩下的所有的边权都＋1

frame 21
CFMI的动机
FMI的硬盘读写太多了，每条路径都需要进行一次读写
有许多子轨迹是被其他子轨迹包含的
通过把所有的子轨迹分成若干组，每一组中的轨迹都是某一条轨迹的后缀
这样只需要从硬盘中读取支配轨迹就可以了

frame 22
包含与严格包含
支配：不被任何一条轨迹严格包含

frame 23
CFMI改进了B＋树中记录的信息
同时，对于每个节点，记录了一张表，上面这个点所有的支配路径的长度

frame 24
对于一个终点和一个时间限制T
CFMI－Search 反返回两个集合
TRREC 是所查询到轨迹的id 起始时间、支配路径id，支配路径起点的集合
DOM 是支配路径id与长度的集合

frame 28
接下来，论文提出了一种在基于动态规划的在Gf上找最频繁路径的算法
引理：去调环后路径会变的更频繁
推论：最频繁路径上不会超过Vf个点

frame 29
加号的定义，求两段路径拼接起来的频繁度
两个特殊记号：
空集、无效集合
无效集合被定义为最不频繁的

frame 30
定义状态F*(v,i),表示从v开始，经过不超过i条边，到达vd的最频繁路径的频繁度
那么显然有，要们时经过了不超过i－1条路径，要么，走了某条出边，然后经过i－1条边

frame 31
算法长得很像Bellman－Ford

frame 33
在讨论算法的有效性时，主要是通过和
MPR
最小经过节点数
比较的
在讨论算法的效率时，主要是通过和最段路来比较的

frame 34
首先是说明了算法的有效性
对于这个问题，论文时举例说明的
Case 1：比MPR靠谱多了
Case 2：MPR找了一条不知道长什么样的小路
Case 3：没走M6这个点，因为这是一条高速路，每出口，MPR一直在走低级道路
Case 4：两个不同的时间段，说明时间限制时有意义的

frame 35
MPR趋向于选去路径上节点尽可能少的
它和LRS有90是一样的
MFP只有10%是选取节点尽可能少的

frame 36
CFMI构造用了两重循环来判断是否包含。。。
直接用trie搞不是线性的么。。。
CFMI存储了更多的信息，所以占的空间也大
作者提出CFMI不需要存储轨迹的id，可以减少空间，表示存疑

frame 37
比最段路慢到不知道哪里去了，10倍以上的差距，这不是显然的么

frame 38
随着轨迹的增加，支配轨迹占轨迹总数在减少，说明CFMI是有意义的
于此同时，响应时间也在增加
tiny dataset 所有数据可以装在内存里
small dataset 假设所有轨迹可以装在内存里
bit dataset 假设轨迹在硬盘上
看出来CFMI特别屌